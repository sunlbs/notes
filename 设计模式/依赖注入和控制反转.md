### 依赖注入(DI)和控制反转(IoC)

#### 1.什么是 *依赖注入* 和 *控制反转*
    
    * 依赖注入 DI  —— Dependency Injection 依赖注入
    * 控制反转 IoC —— Inversion of Control 控制反转
    
    
##### 什么是依赖注入

没有你我就活不下去，那么，你就是我的依赖。 说白了就是：

    不是我自身的，却是我需要的，都是我所依赖的。一切需要外部提供的，都是需要进行依赖注入的。
    
##### 依赖注入举例

```php
class Boy {
  protected $girl;
 
  public function __construct(Girl $girl) {
    $this->girl = $girl;
  }
}
 
class Girl {
  ...
}
 
$boy = new Boy();  // Error; Boy must have girlfriend!
 
// 所以，必须要给他一个女朋友才行
$girl = new Girl();
 
$boy = new Boy($girl); // Right! So Happy!
```

从上述代码我们可以看到Boy强依赖Girl必须在构造时注入Girl的实例才行。
那么为什么要有依赖注入这个概念，依赖注入到底解决了什么问题？
我们将上述代码修正一下我们初学时都写过的代码：

```php
class Boy {
  protected $girl;
 
  public function __construct() {
    $this->girl = new Girl();
  }
}
```

这种方式与前面的方式有什么不同呢？
我们会发现 `Boy` 的女朋友被我们硬编码到 `Boy` 的身体里去了。。。 每次`Boy`重生自己想换个类型的女朋友都要把自己扒光才行。
某天`Boy`特别喜欢一个`LoliGirl` ,非常想让她做自己的女朋友。。。怎么办？ 重生自己。。。扒开自己。。。把`Girl`扔了。。。把 `LoliGirl`塞进去。。。

```php
class LoliGirl {
 
}
 
class Boy {
  protected $girl;
 
  public function __construct() {
      //  $this->girl = new Girl();  // sorry...
      $this->girl = new LoliGirl();
  }
}
```
某天 `Boy`迷恋上了御姐....`Boy` 好烦。。。
是不是感觉不太好？每次遇到真心相待的人却要这么的折磨自己。。。
`Boy`说，我要变的强大一点。我不想被改来改去的！
好吧，我们让`Boy`强大一点：

```php
interface Girl {
  // Boy need knows that I have some abilities.
}
 
class LoliGril implement Girl {
  // I will implement Girl's abilities.
}
 
class Vixen implement Girl {
  // Vixen definitely is a girl, do not doubt it.
}
 
class Boy {
  protected $girl;
 
  public function __construct(Girl $girl) {
    $this->girl = $girl;
  }
}
 
$loliGirl = new LoliGirl();
$vixen = new Vixen();
 
$boy = new Boy($loliGirl);
$boy = new Boy($vixen);
```

`Boy` 很高兴，终于可以不用扒开自己就可以体验不同的人生了。。。So Happy!

##### 依赖注入方式

###### 1、构造器 注入

```php
<?php
class Book {
  private $db_conn;
  
  public function __construct($db_conn) {
    $this->db_conn = $db_conn;
  }
}
```

###### 2、setter 注入

```php
<?php
class Book {
    private $db;
    private $file;
 
    function setdb($db) {
        $this->db = $db;
    }
 
    function setfile($file) {
        $this->file = $file;
    }
}
 
class file {
}
 
class db {
}
 
// ...
 
class test {
    $book = new Book();
    $book->setdb(new db());
    $book->setfile(new file());
}
```

    小结：
    因为大多数应用程序都是由两个或者更多的类通过彼此合作来实现业务逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么将导致代码高度耦合并且难以维护和调试。


所以才有了依赖注入的概念，依赖注入解决了以下问题：

* 依赖之间的解耦
* 单元测试，方便Mock

上面俩种方法代码很清晰，但是当我们需要注入很多个依赖时，意味着又要增加很多行，会比较难以管理。

比较好的解决办法是 建立一个class作为所有依赖关系的container，在这个class中可以存放、创建、获取、查找需要的依赖关系。先来了解一下IOC的概念

##### 控制反转 （Inversion Of Control, IOC）



